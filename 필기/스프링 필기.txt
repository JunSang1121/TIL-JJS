 -------------------------------------------------
SingleTon Container (싱글톤 컨테이너)


사용이유:
객체 인스턴스를 하나만 생성해서 관리하기 위함.
사용하지 않으면 new 명령어를 통해 다수의 사용자가 여러개의 객체를 생성 ->비효율적.
DIP, OCP 오류.

사용법:
ex) ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class)

AppConfig에 속해있는 Bean 꺼내온 후 사용

스프링의 기본 빈 등록 방식은 싱글톤. But 요청시 새로운 객체를 생성하여 반환 가능. 

싱글톤 방식의 주의점 - 여러 클라이언트가 하나의 같은 객체를 공유하기 때문에 상태를 유지하게 설계하면 안된다.

무상태로 설계해야 한다.
	1. 특정 클라이언트에 의존적인 필드가 있으면 안된다.
	2. 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안되다.
	3. 가급적 읽기만 가능해야 한다.
	4. 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal등을 사용해야 한다.

공용되게 사용시 A,B 사용자가 동시 결제를 할때 A사용자의 결제금액이 바뀔 수 있다. 


@Configuration

코드의 TEST 폴더 내 COnfigurationTest 코드를 보면 MemberMemoryRepository 를 호출하는 메서드가 3개 나온다. 이것들은 각 각 선언되어 3개의 인스턴스를 생성하는것일까?

-> 스프링 컨테이너는 하나의 객체를 사용하도록 스프링 빈이 싱글톤을 보장해준다. 모든 비밀은 @Configuration을 적용한 AppConfig에 있다.

AnnotationConfigApplicationContext에 파라미터로 넘긴 값은 스프링 빈에 등록되기에 AppConfig도 스프링 빈이다.

따라서 AppConfig도 스프링컨테이너의 관리하에 AppConfig@CGLIB로 중복 인스턴스가 생성되지 않는다.


@Bean만 사용시 스프링 빈으로 등록되지만, 싱글톤은 보장하지 않는다. 

 -------------------------------------------------
ComponentScan (컴포넌트 스캔)


@Component 어노테이션이 붙어있는 클래스들을 전부 Bean으로 등록시키는 과정이다.

컴포넌트 스캔을 사용하기 위해서는  @ComponentScan 어노테이션을 붙여야 하며 이때 컴포넌트 스캔의 범위는 설정 정보 클래스의 패키지를 포함한 모든 하위 패키지이다.
모든 자바 클래스를 컴포넌스 스캔하면 시간이 오래 걸릴 수 있으니 basePackages = ""를 통해 탐색 시작 위치를 정할 수 있다.

Ex) 

@ComponentScan( 
	basePackages = "hello.core"
)

컴포넌트 스캔 기본 대상

@Component : 컴포넌트 스캔에서 사용
@Controller : 스프링 MVX 컨트롤러에서 사용
@Service : 스프링 비즈니스 로직에서 사용
@Repository : 스프링 데이터 접근 계층에서 사용
@Configuration : 스프링 설정 정보에서 사용

 -------------------------------------------------

Filter (필터)

includeFilter : 컴포넌트 스탠 대상을 추가로 지정한다.
excludeFilter : 컴포넌트 스탠에서 제외할 대싱을 지정한다.
